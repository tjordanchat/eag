#!/bin/cpnl

	++cpl 'me@company.com'.

	guest '*@company.com' ++add_issue.
	guest.

	'[(f1 f2 f3)(f4 f5)f6] (f1 f2)'.

	layout_B '(f4 [f5 f6]) [f1 f5 f6]'.

	cpl %b "Create Project Leader" ? plname "Project Leader" %h ? PM +plname.

	PM ++users ++user ++releases ++issues ++issue ++pair_release_issue..

	cproj %b "Create Project" ? project %s "Project name" ? +users, +releases, +issues, +pair_release_issue ? next.

			users %b "New user" ? users.user.
			user "User name" %h ? pusers=+user.

			releases %b "New Release" ? releases.release.
			release "Release name" %s ? +handle_release.
			
			handle_release ? r_name , r_due , +pair_release_issue .

			issues %b "New Issue" > issues.issue.
			issue %a "Issue Id" ? +handle_issue.
			
			handle_issue ? issue_summary,	issue_description, issue_severity, issue_originator ? 

			pair_release_issue %b ? release_name, issue_id ? %b "Submit" ++PM ? release_name.issues=+issue_id.

	function1(arg1,arg2,arg3,arg4,arg5) {
			releases $arg1 $arg2 ? function1.thing.
			thing $arg3 $arg4 ? $arg5.
	}
	
	a,b?c=2.
	@now?r.a?s.b.



#
# is '[]' bracks for E() and '{} for A().
#
# ie. [ a, b, c ] ? d(c1), e(c2), f(c3).
# forEach (ie '[]') blocks are needed because sometime a 
# process does not return.
#
# c1 c2 & c3 have to evaluate to a truth value immediately. They can not be something that has to be
# wait for like a human interaction for a field or a duration of time to pass.
#
# forEach blocks can occure beyond the beginning.
# ie. [ a, b, c ] ? [ d. e ] ? f.
# 
# a project needs to be able to create a list of roles and add a list of people to each 
# role.



  project_adder ++-add_users +--pname +--pdesc -+-ppri +--pmgr ++-create_project.
  project_adder = +admin.

	project ? project_owner ++-issue.
	oldest_feature = *project.*issue(type~feature).age>*.
	projects.issues(issue_type.2&issue_owner~myguys&10000<dept_id<20000&%(var22)>5)?.
	PM= +cproj.
	project.p_name ~ /_X_/ ? issues.owner ~ /jbob/ ? loop1.
	func1 ? *project.*issues.i_owner ~ /^%(var_from_name3)$/ ? i_owner  var_to_name3.
	*project.*issues.i_owner ~ /^jtj/ ? i_owner  PM.
	*project.*issues.last_activity > @5d ? i_owner++-? notify.
	*project.*issue.*?last_activity  @now.
	project_id  0.
	pname %s "Project Name". 
	pmgr   [] "Project Manager". 
	PM ---f4 ++-pname +--create_project.
	admin ++-add_uses ++-add_project_mgr.
	create_project   %b   "Create Project".
	add_project_mgr   %b   "Add Project Manager".
	l_name   []  "List of Projects" 




	r1 ++-f1+--f2---pname.
	r2 +--f3++-f5. 
  pmgr  ++-add_users ++-pname ++-pdesc ++-ppri.
	choose_floor_buttons  ++-floor1_but ++-floor2_but ++-floor3_but.
	johnc john@home.com ++-customer_reason "John Cusack".
	date1 %t "Date".
	f1 %d "Dollar Amount".
	c %h "Customer Name".
	pmgr  c.
	Fixed   %b   "Fixed".
	add_users   %b   "Add User".
	create_issue   %b   "Create Issue".
  button1_pushed   %b   "Button 1".
	hello_world   "Hello world".
	comment   %30s   "Add Comment" (comments=+comment?comment=).
	comments "Previous Comments" [].
	tstrslt  l1 "Test Results". 
	l1  [ "accept" "reject" "abstain" ] (env=qa?adv_issue).
	l2  [ "Gathering Information" "Reject" ].
	l3  [ "Bug" "Feature" "Enhancement" ].
	issue_id  0.
	holiday_days @Dec25 @Jul4 @Feb2.
	f5  ext1().
	timer1  @5m12s.
	ticks  @4a.
	secondtuesecmonth  @2M2tue.
	xmas  @Dec25.
	katie.daughter  suri.


	ancestor=parent,parent.ancestor.

	(	cond?exec(),cond?exec()?next(),cond?exec() ) ? then_next().

	[ a, b, c ] ? d(c1), e(c2), f(c3).



	release.issue.patch ? test_patch.

	release.issue.env.result~pass?closed_releases=+release.

	test_patch ? 

	int "Integration" %b ().
	release.env ~ qa ? mailinfo.to=qa_lead, mailinfo.msg="please test %(env)"?mail().
	
	release.issue.test_result ?   
	
	@now ? +a1, a.
	R1 ? a ? b ? c.
	b?@5m?bell().
	a,b ? pass(f3.1), fail(f3.2), abstain(f3.3).
	a,E(b1,b2),c?d,e? w, x.
	A(d,e) ? e(f1>4), c(f1<4). 
	E(e,b,c) ? d(f1>4), e(f1<4). 
	E(d,e) ? p(@12am), f(f6~2). 
	a, b ? f1++, f26, f5=f2/f4 , next.
	a ? b, c? d.
	deli?ext_delq(a*.children.age).

